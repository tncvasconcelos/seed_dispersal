sqrt(diag(pseudoinverse(t(W)%*%pseudoinverse(V)%*%W)))
expected.vals
logl
data(tworegime)
#Plot the tree and the internal nodes to highlight the selective regimes:
select.reg<-character(length(tree$node.label))
select.reg[tree$node.label == 1] <- "black"
select.reg[tree$node.label == 2] <- "red"
plot(tree)
nodelabels(pch=21, bg=select.reg)
PhyloLMDat <- trait[,3]
StdErr <- abs(rnorm(length(trait[,3]), sd(trait[,3])/5, sd(trait[,3])/10))
trait[,4] <- StdErr
names(PhyloLMDat) <- trait[,1]
# OUwieRes <- OUwie(tree,trait,model=c("OUM"),root.station=FALSE)
# alpha=c(OUwieRes$solution[1,])
# sigma.sq=c(OUwieRes$solution[2,])
# theta=c(OUwieRes$theta[1,1], OUwieRes$theta[1,1])
alpha=c(0.01, 0.01)
sigma.sq=c(0.02, 0.02)
theta=c(0, 0)
OUwie.fixed(tree,trait,model=c("OUM"), simmap.tree=FALSE, scaleHeight=FALSE, mserr = "known",
clade=NULL, alpha=alpha,sigma.sq=sigma.sq,theta=theta, algorithm = "invert")
debug(dev.fixed())
debug(dev.fixed
)
fixed.fit <- dev.fixed()
N <- length(x
)
V <- varcov.ou(phy, edges, Rate.mat, root.state = root.state,
simmap.tree = simmap.tree, root.age = root.age,
scaleHeight = scaleHeight, assume.station = root.station,
shift.point = shift.point)
diag(V) <- diag(V)+(data[,3]^2)
theta.est <- cbind(theta,se)
#When the model includes alpha, the values of V can get too small, the modulus does not seem correct and the loglik becomes unstable. This is one solution:
DET <- sum(log(abs(Re(diag(qr(V)$qr)))))
logl <- -.5*(t(x-W%*%theta)%*%pseudoinverse(V)%*%(x-W%*%theta))-.5*as.numeric(DET)-.5*(N*log(2*pi))
logl
best <- logl
logl
pars <- matrix(c(Rate.mat[3,], Rate.mat[2,], Rate.mat[1,]), dim(Rate.mat)[2], 3, dimnames = list(levels(tot.states), c("opt", "sig", "alp")))
expected.vals <- colSums(t(W) * pars[,1])
names(expected.vals) <- phy$tip.label
expected.vals
pars <- matrix(c(Rate.mat[3,], Rate.mat[2,], Rate.mat[1,]), dim(Rate.mat)[2], 3, dimnames = list(levels(tot.states), c("opt", "sig", "alp")))
OUwie.fixed(tree,trait,model=c("OUM"), simmap.tree=FALSE, scaleHeight=FALSE, mserr = "known",
clade=NULL, alpha=alpha,sigma.sq=sigma.sq,theta=theta, algorithm = "three.point")
debug(dev.fixed)
fixed.fit <- dev.fixed()
expected.vals
best
N <- length(x
)
V <- varcov.ou(phy, edges, Rate.mat, root.state=root.state, simmap.tree=simmap.tree, root.age=root.age, scaleHeight=scaleHeight, assume.station=root.station, shift.point=shift.point)
diag(V) <- diag(V)+(data[,3]^2)
DET <- sum(log(abs(Re(diag(qr(V)$qr)))))
logl <- -.5*(t(x-W%*%theta)%*%pseudoinverse(V)%*%(x-W%*%theta))-.5*as.numeric(DET)-.5*(N*log(2*pi))
logl
best <- logl
transformed.tree <- transformPhy(phy, map, pars, tip.paths)
transformed.tree
TIPS <- transformed.tree$tree$edge[,2] <= length(transformed.tree$tree$tip.label)
transformed.tree$tree$edge.length[TIPS] <- transformed.tree$tree$edge.length[TIPS] + data[,3]^2
comp <- phylolm::three.point.compute(transformed.tree$tree, x, expected.vals, transformed.tree$diag)
logl <- -as.numeric(Ntip(phy) * log(2 * pi) + comp$logd + (comp$PP - 2 * comp$QP + comp$QQ))/2
logl
?phylolm::three.point.compute(transformed.tree$tree, x, expected.vals, transformed.tree$diag)
logl
phy2 <- phy
phy2 <- phy
TIPS <- phy2$edge[,2] <= length(phy2$tip.label)
phy2$edge.length[TIPS] <- phy2$edge.length[TIPS] + data[,3]^2
transformed.tree <- transformPhy(phy2, map, pars, tip.paths)
transformed.tree
comp <- phylolm::three.point.compute(transformed.tree$tree, x, expected.vals, transformed.tree$diag)
logl <- -as.numeric(Ntip(phy) * log(2 * pi) + comp$logd + (comp$PP - 2 * comp$QP + comp$QQ))/2
logl
best
phy
transformed.tree <- transformPhy(phy, map, pars, tip.paths)
TIPS <- transformed.tree$tree$edge[,2] <= length(transformed.tree$tree$tip.label)
transformed.tree$tree$edge.length[TIPS] <- transformed.tree$tree$edge.length[TIPS] + data[,3]^2
transformed.tree$diag <- transformed.tree$diag + data[,3]^2
comp <- phylolm::three.point.compute(transformed.tree$tree, x, expected.vals, transformed.tree$diag)
logl <- -as.numeric(Ntip(phy) * log(2 * pi) + comp$logd + (comp$PP - 2 * comp$QP + comp$QQ))/2
logl
best
transformed.tree <- transformPhy(phy, map, pars, tip.paths)
TIPS <- transformed.tree$tree$edge[,2] <= length(transformed.tree$tree$tip.label)
transformed.tree$tree$edge.length[TIPS] <- transformed.tree$tree$edge.length[TIPS] + data[,3]^2
transformed.tree$diag <- transformed.tree$diag + data[,3]^2
comp <- phylolm::three.point.compute(transformed.tree$tree, x, expected.vals, transformed.tree$diag)
logl <- -as.numeric(Ntip(phy) * log(2 * pi) + comp$logd + (comp$PP - 2 * comp$QP + comp$QQ))/2
logl
This is an [R Markdown](http://rmarkdown.rstudio.com) Notebook. When you execute code within the notebook, the results appear beneath the code.
Try executing this chunk by clicking the *Run* button within the chunk or by placing your cursor inside it and pressing *Cmd+Shift+Enter*.
```{r}
plot(cars)
plot(cars)
wd <- "~/2021_SeedDispersal/"
setwd(wd)
dir("res_corhmm/")
Rsaves <- dir("res_corhmm/")
Rsaves
paste0(wdm dir("res_corhmm/"))
paste0(wd, dir("res_corhmm/"))
Rsaves <- paste0(wd, dir("res_corhmm/"))
Rsaves
Rsave <- Rsaves[1]
Rsave
Rsaves <- paste0(wd, dir("res_corhmm/"))
Rsaves <- paste0(wd, dir("res_corhmm/"))
Rsave
load(Rsave)
Rsaves <- paste0(wd, "res_corhmm/", dir("res_corhmm/"))
Rsaves
Rsave <- Rsaves[1]
load(Rsave)
lapply(obj, function(x) x$AICc)
file <- Rsaves[1]
file
load(file)
obj
length(obj)
length(obj)
# the results table
ResTable <- matrix(0, length(obj), 5)
rownames(ResTable) <- rep(c("ER", "ARD", "ER/ER", "ARD/ARD", "ER/ARD"), length(obj)/7)
ResTable
c("ER", "ARD", "ER/ER", "ARD/ARD", "ER/ARD")
rownames(ResTable) <- c("ER", "ARD", "ER/ER", "ARD/ARD", "ER/ARD")
ResTable
colnames(ResTable) <- c("k.rate", "AICc", "AICcWt", "MeanRate", "ASR")
count <- 1
i = 1
CorRes_i <- obj[[i]]
CorRes_i
Model <- CorRes_i$solution
Model
AICc <- round(CorRes_i$AICc, 2)
AICwt <- 0
MeanRate <- round(mean(CorRes_i$solution, na.rm = TRUE),2)
Model[is.na(Model)] <- 0
ASR <-  round(CorRes_i$states[1,][which.max(CorRes_i$states[1,])], 2)
ASR <-  paste(names(ASR), paste(ASR*100, "%", sep = ""))
ASR
round(CorRes_i$states[1,][which.max(CorRes_i$states[1,])], 2)
CorRes_i$states[1,]
CorRes_i
CorRes_i$data
CorRes_i$data.legend
CorRes_i$data
CorRes_i <- obj[[i]]
Model <- CorRes_i$solution
AICc <- round(CorRes_i$AICc, 2)
AICwt <- 0
MeanRate <- round(mean(CorRes_i$solution, na.rm = TRUE),2)
Model[is.na(Model)] <- 0
ASR <-  round(CorRes_i$states[1,][which.max(CorRes_i$states[1,])], 2)
ASR <-  paste(names(ASR), paste(ASR*100, "%", sep = ""))
k.rate <- max(CorRes_i$index.mat, na.rm = TRUE)
diag(Model) <- -rowSums(Model)
Eq <- c(Null(Model))/sum(Null(Model))
Eq
## imports
require(MASS)
CorRes_i <- obj[[i]]
Model <- CorRes_i$solution
AICc <- round(CorRes_i$AICc, 2)
AICwt <- 0
MeanRate <- round(mean(CorRes_i$solution, na.rm = TRUE),2)
Model[is.na(Model)] <- 0
ASR <-  round(CorRes_i$states[1,][which.max(CorRes_i$states[1,])], 2)
ASR <-  paste(names(ASR), paste(ASR*100, "%", sep = ""))
k.rate <- max(CorRes_i$index.mat, na.rm = TRUE)
diag(Model) <- -rowSums(Model)
Eq <- c(Null(Model))/sum(Null(Model))
EntUncond <- sum(Eq*-log2(Eq))
EntCond <- mean(rowSums(CorRes_i$states * -log2(CorRes_i$states)))
MutInfo <- round(EntUncond - EntCond, 2)
#PropInfo <- round(MutInfo/EntUncond*100, 2)
ResTable[count,] <- c(k.rate, AICc, AICwt, MeanRate, ASR)
ResTable
for(i in 1:length(obj)){
CorRes_i <- obj[[i]]
Model <- CorRes_i$solution
AICc <- round(CorRes_i$AICc, 2)
AICwt <- 0
MeanRate <- round(mean(CorRes_i$solution, na.rm = TRUE),2)
Model[is.na(Model)] <- 0
ASR <-  round(CorRes_i$states[1,][which.max(CorRes_i$states[1,])], 2)
ASR <-  paste(names(ASR), paste(ASR*100, "%", sep = ""))
k.rate <- max(CorRes_i$index.mat, na.rm = TRUE)
diag(Model) <- -rowSums(Model)
Eq <- c(Null(Model))/sum(Null(Model))
EntUncond <- sum(Eq*-log2(Eq))
EntCond <- mean(rowSums(CorRes_i$states * -log2(CorRes_i$states)))
MutInfo <- round(EntUncond - EntCond, 2)
#PropInfo <- round(MutInfo/EntUncond*100, 2)
ResTable[count,] <- c(k.rate, AICc, AICwt, MeanRate, ASR)
count <- count + 1
}
ResTable
AICcs <- as.numeric(ResTable[,2])
ResTable[,3] <- round(exp(-0.5 * AICcs - min(AICcs))/sum(exp(-0.5 * AICcs - min(AICcs))),2 )
ResTable[ResTable[,3] < 0.001,3] <- "<0.001"
ResTable[ResTable[,4] < 0.001,4] <- "<0.001"
ResTable
table.name <- paste("ResTable_", gsub(".Rsave", ".csv", file), sep = "")
table.name
ResTable
getwd()
table.name
file
table.name <- gsub(".Rsave", ".csv", file)
table.name
file
load(file)
rate.mats <- lapply(obj, function(x) x$solution)
rate.mats
MaxRate <- max(unlist(lapply(rate.mats, function(x) dim(x)[1])))
res <- rep("~", MaxRate)
res
i = 1
rate.mat_i <- round(rate.mats[[i]], 2)
rate.mat_i
rate.mat_i[!is.na(rate.mat_i) & rate.mat_i == 0] <- "<0.001"
rate.mat_i
rate.mat_i <- round(rate.mats[[i]], 4)
rate.mat_i
rate.mat_i <- round(rate.mats[[i]], 3)
rate.mat_i
rate.mat_i[!is.na(rate.mat_i) & rate.mat_i == 0] <- "<0.001"
rate.mat_i
dim(rate.mat_i)[1]
MaxRate
dim(rate.mat_i)[1] < MaxRate
file
load(file)
# the results table
AICcs <- unlist(lapply(obj, function(x) x$AICc))
AICwt <- exp(-0.5 * AICcs - min(AICcs))/sum(exp(-0.5 * AICcs - min(AICcs)))
AICwt
res <- matrix(0, dim(obj[[1]]$states)[1], dim(obj[[1]]$states)[2])
res
for(i in 1:length(obj)){
States <- colnames(obj[[i]]$solution)
if(length(grep("R2", States)) == 0){
ASR_i <- obj[[i]]$states[,grep("R1", States)]
}else{
ASR_i <- obj[[i]]$states[,grep("R1", States)] + obj[[i]]$states[,grep("R2", States)]
}
res <- res + (ASR_i * AICwt[i])
}
States
ASR_i
getWeightedASR <- function(file){
load(file)
# the results table
AICcs <- unlist(lapply(obj, function(x) x$AICc))
AICwt <- exp(-0.5 * AICcs - min(AICcs))/sum(exp(-0.5 * AICcs - min(AICcs)))
res <- matrix(0, dim(obj[[1]]$states)[1], dim(obj[[1]]$states)[2])
for(i in 1:length(obj)){
States <- colnames(obj[[i]]$solution)
if(length(grep("R2", States)) == 0){
ASR_i <- obj[[i]]$states[,grep("R1", States)]
}else{
ASR_i <- obj[[i]]$states[,grep("R1", States)] + obj[[i]]$states[,grep("R2", States)]
}
res <- res + (ASR_i * AICwt[i])
}
table.name <- paste("ASRTable_", gsub(".Rsave", ".csv", file), sep = "")
write.csv(res, file = table.name)
return(res)
}
Rsaves[1]
dir("res_corhmm/")
strsplit(dir("res_corhmm/"), sep = "-")
strsplit(dir("res_corhmm/"), sep = "\-")
strsplit(dir("res_corhmm/"), sep = "\\-")
strsplit(dir("res_corhmm/"), "-")
lapply(strsplit(dir("res_corhmm/"), "-"))[1]
lapply(strsplit(dir("res_corhmm/"), "-"), function(x) x[1])
labels <- unlist(lapply(strsplit(dir("res_corhmm/"), "-"), function(x) x[1]))
source('~/2021_SeedDispersal/20.12.15-analyzeCorHMM.R', echo=TRUE)
labels
labels
Rsaves
Rsaves <- paste0(wd, "rsave_corhmm/", dir("rsave_corhmm/"))
labels <- unlist(lapply(strsplit(dir("rsave_corhmm/"), "-"), function(x) x[1]))
labels
Rsaves
table.name <- gsub(".Rsave", ".csv", file)
table.name
table.name <- gsub(".Rsave", ".csv", file)
table.name <- gsub("rsave_corhmm", "table_corhmm", file)
table.name
file <- Rsaves
table.name <- gsub(".Rsave", ".csv", file)
table.name <- gsub("rsave_corhmm", "table_corhmm", file)
table.name
## functions
## functions
# saves the results table and returns it
getResultsTable <- function(file){
load(file)
# the results table
ResTable <- matrix(0, length(obj), 5)
rownames(ResTable) <- c("ER", "ARD", "ER/ER", "ARD/ARD", "ER/ARD")
colnames(ResTable) <- c("k.rate", "AICc", "AICcWt", "MeanRate", "ASR")
count <- 1
for(i in 1:length(obj)){
CorRes_i <- obj[[i]]
Model <- CorRes_i$solution
AICc <- round(CorRes_i$AICc, 2)
AICwt <- 0
MeanRate <- round(mean(CorRes_i$solution, na.rm = TRUE),2)
Model[is.na(Model)] <- 0
ASR <-  round(CorRes_i$states[1,][which.max(CorRes_i$states[1,])], 2)
ASR <-  paste(names(ASR), paste(ASR*100, "%", sep = ""))
k.rate <- max(CorRes_i$index.mat, na.rm = TRUE)
diag(Model) <- -rowSums(Model)
Eq <- c(Null(Model))/sum(Null(Model))
EntUncond <- sum(Eq*-log2(Eq))
EntCond <- mean(rowSums(CorRes_i$states * -log2(CorRes_i$states)))
MutInfo <- round(EntUncond - EntCond, 2)
#PropInfo <- round(MutInfo/EntUncond*100, 2)
ResTable[count,] <- c(k.rate, AICc, AICwt, MeanRate, ASR)
count <- count + 1
}
AICcs <- as.numeric(ResTable[,2])
ResTable[,3] <- round(exp(-0.5 * AICcs - min(AICcs))/sum(exp(-0.5 * AICcs - min(AICcs))),2 )
ResTable[ResTable[,3] < 0.001,3] <- "<0.001"
ResTable[ResTable[,4] < 0.001,4] <- "<0.001"
table.name <- gsub(".Rsave", ".csv", file)
table.name <- gsub("rsave_corhmm", "table_corhmm", file)
write.csv(ResTable, file = table.name)
return(ResTable)
}
getModelRateMats <- function(file){
load(file)
rate.mats <- lapply(obj, function(x) x$solution)
MaxRate <- max(unlist(lapply(rate.mats, function(x) dim(x)[1])))
res <- rep("~", MaxRate)
for(i in 1:length(obj)){
rate.mat_i <- round(rate.mats[[i]], 3)
rate.mat_i[!is.na(rate.mat_i) & rate.mat_i == 0] <- "<0.001"
if(dim(rate.mat_i)[1] < MaxRate){
rate.mat_i <- rbind(rownames(rate.mat_i), rate.mat_i)
rate.mat_i <- cbind(rate.mat_i, matrix("!", MaxRate - dim(rate.mat_i)[1] + 2, MaxRate - dim(rate.mat_i)[2]))
rate.mat_i <- rbind(rate.mat_i, " ")
rate.mat_i <- rbind(rate.mat_i, "~")
res <- rbind(res, rate.mat_i)
}else{
rate.mat_i <- rbind(rownames(rate.mat_i), rate.mat_i)
rate.mat_i <- rbind(rate.mat_i, " ")
rate.mat_i <- rbind(rate.mat_i, "~")
res <- rbind(res, rate.mat_i)
}
}
table.name <- gsub(".Rsave", ".csv", file)
table.name <- gsub("rsave_corhmm", "table_corhmm", file)
write.csv(res, file = table.name)
return(res)
}
getWeightedASR <- function(file){
load(file)
# the results table
AICcs <- unlist(lapply(obj, function(x) x$AICc))
AICwt <- exp(-0.5 * AICcs - min(AICcs))/sum(exp(-0.5 * AICcs - min(AICcs)))
res <- matrix(0, dim(obj[[1]]$states)[1], dim(obj[[1]]$states)[2])
for(i in 1:length(obj)){
States <- colnames(obj[[i]]$solution)
if(length(grep("R2", States)) == 0){
ASR_i <- obj[[i]]$states[,grep("R1", States)]
}else{
ASR_i <- obj[[i]]$states[,grep("R1", States)] + obj[[i]]$states[,grep("R2", States)]
}
res <- res + (ASR_i * AICwt[i])
}
table.name <- gsub(".Rsave", ".csv", file)
table.name <- gsub("rsave_corhmm", "table_corhmm", file)
write.csv(res, file = table.name)
return(res)
}
# set wd
wd <- "~/2021_SeedDispersal/"
setwd(wd)
Rsaves <- paste0(wd, "rsave_corhmm/", dir("rsave_corhmm/"))
labels <- unlist(lapply(strsplit(dir("rsave_corhmm/"), "-"), function(x) x[1]))
Rsaves
Rsaves
for(i in Rsaves){
getResultsTable(i)
getModelRateMats(i)
getWeightedASR(i)
}
getResultsTable
i
getResultsTable(i)
getResultsTable(i)
table.name
Rsaves
getResultsTable(i)
getModelRateMats(i)
getWeightedASR(i)
getResultsTable(i)
file
file
file <- file[1]
table.name <- gsub(".Rsave", ".csv", file)
table.name <- gsub("rsave_corhmm", "table_corhmm", table.name)
table.name <- gsub("corRes", "ASR", table.name)
table.name
## functions
## functions
# saves the results table and returns it
getResultsTable <- function(file){
load(file)
# the results table
ResTable <- matrix(0, length(obj), 5)
rownames(ResTable) <- c("ER", "ARD", "ER/ER", "ARD/ARD", "ER/ARD")
colnames(ResTable) <- c("k.rate", "AICc", "AICcWt", "MeanRate", "ASR")
count <- 1
for(i in 1:length(obj)){
CorRes_i <- obj[[i]]
Model <- CorRes_i$solution
AICc <- round(CorRes_i$AICc, 2)
AICwt <- 0
MeanRate <- round(mean(CorRes_i$solution, na.rm = TRUE),2)
Model[is.na(Model)] <- 0
ASR <-  round(CorRes_i$states[1,][which.max(CorRes_i$states[1,])], 2)
ASR <-  paste(names(ASR), paste(ASR*100, "%", sep = ""))
k.rate <- max(CorRes_i$index.mat, na.rm = TRUE)
diag(Model) <- -rowSums(Model)
Eq <- c(Null(Model))/sum(Null(Model))
EntUncond <- sum(Eq*-log2(Eq))
EntCond <- mean(rowSums(CorRes_i$states * -log2(CorRes_i$states)))
MutInfo <- round(EntUncond - EntCond, 2)
#PropInfo <- round(MutInfo/EntUncond*100, 2)
ResTable[count,] <- c(k.rate, AICc, AICwt, MeanRate, ASR)
count <- count + 1
}
AICcs <- as.numeric(ResTable[,2])
ResTable[,3] <- round(exp(-0.5 * AICcs - min(AICcs))/sum(exp(-0.5 * AICcs - min(AICcs))),2 )
ResTable[ResTable[,3] < 0.001,3] <- "<0.001"
ResTable[ResTable[,4] < 0.001,4] <- "<0.001"
table.name <- gsub(".Rsave", ".csv", file)
table.name <- gsub("rsave_corhmm", "table_corhmm", table.name)
table.name <- gsub("corRes", "ResTable", table.name)
write.csv(ResTable, file = table.name)
return(ResTable)
}
getModelRateMats <- function(file){
load(file)
rate.mats <- lapply(obj, function(x) x$solution)
MaxRate <- max(unlist(lapply(rate.mats, function(x) dim(x)[1])))
res <- rep("~", MaxRate)
for(i in 1:length(obj)){
rate.mat_i <- round(rate.mats[[i]], 3)
rate.mat_i[!is.na(rate.mat_i) & rate.mat_i == 0] <- "<0.001"
if(dim(rate.mat_i)[1] < MaxRate){
rate.mat_i <- rbind(rownames(rate.mat_i), rate.mat_i)
rate.mat_i <- cbind(rate.mat_i, matrix("!", MaxRate - dim(rate.mat_i)[1] + 2, MaxRate - dim(rate.mat_i)[2]))
rate.mat_i <- rbind(rate.mat_i, " ")
rate.mat_i <- rbind(rate.mat_i, "~")
res <- rbind(res, rate.mat_i)
}else{
rate.mat_i <- rbind(rownames(rate.mat_i), rate.mat_i)
rate.mat_i <- rbind(rate.mat_i, " ")
rate.mat_i <- rbind(rate.mat_i, "~")
res <- rbind(res, rate.mat_i)
}
}
table.name <- gsub(".Rsave", ".csv", file)
table.name <- gsub("rsave_corhmm", "table_corhmm", table.name)
table.name <- gsub("corRes", "QMat", table.name)
write.csv(res, file = table.name)
return(res)
}
getWeightedASR <- function(file){
load(file)
# the results table
AICcs <- unlist(lapply(obj, function(x) x$AICc))
AICwt <- exp(-0.5 * AICcs - min(AICcs))/sum(exp(-0.5 * AICcs - min(AICcs)))
res <- matrix(0, dim(obj[[1]]$states)[1], dim(obj[[1]]$states)[2])
for(i in 1:length(obj)){
States <- colnames(obj[[i]]$solution)
if(length(grep("R2", States)) == 0){
ASR_i <- obj[[i]]$states[,grep("R1", States)]
}else{
ASR_i <- obj[[i]]$states[,grep("R1", States)] + obj[[i]]$states[,grep("R2", States)]
}
res <- res + (ASR_i * AICwt[i])
}
table.name <- gsub(".Rsave", ".csv", file)
table.name <- gsub("rsave_corhmm", "table_corhmm", table.name)
table.name <- gsub("corRes", "ASR", table.name)
write.csv(res, file = table.name)
return(res)
}
# set wd
wd <- "~/2021_SeedDispersal/"
setwd(wd)
Rsaves <- paste0(wd, "rsave_corhmm/", dir("rsave_corhmm/"))
labels <- unlist(lapply(strsplit(dir("rsave_corhmm/"), "-"), function(x) x[1]))
for(i in Rsaves){
getResultsTable(i)
getModelRateMats(i)
getWeightedASR(i)
}
