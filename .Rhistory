select.reg<-character(length(tree$node.label))
select.reg[tree$node.label == 1] <- "black"
select.reg[tree$node.label == 2] <- "red"
tree$edge.length <- tree$edge.length/max(branching.times(tree))
StdErr <- c(0.00, 0.02, 0.05, 0.1, 0.2, 0.5, 1, 2)
LikRes <- matrix(NA, 2, length(StdErr), dimnames = list(c("Invert", "3-point"), StdErr))
for(i in 1:length(StdErr)){
trait[,4] <- abs(rnorm(length(tree$tip.label), mean = StdErr[i], sd = StdErr[i]/10))
alpha=c(1, 2)
sigma.sq=c(1, 2)
theta=c(5, 10)
INV <- OUwie.fixed(tree,trait,model=c("OUMVA"), simmap.tree=FALSE, scaleHeight=FALSE, mserr = "known", clade=NULL, alpha=alpha,sigma.sq=sigma.sq,theta=theta, algorithm = "invert")$loglik
TPT <- OUwie.fixed(tree,trait,model=c("OUMVA"), simmap.tree=FALSE, scaleHeight=FALSE, mserr = "known", clade=NULL, alpha=alpha,sigma.sq=sigma.sq,theta=theta, algorithm = "three.point")$loglik
LikRes[,i] <- c(INV, TPT)
}
LikRes
require(corHMM)
require(OUwie)
require(parallel)
require(geiger)
require(proftools)
phy <- sim.bdtree(b = 1, d = 0.5, stop = "taxa", n = 250)
phy <- drop.extinct(phy)
root.p = c(0.5, 0.5)
p.mk <- c(0.5, 0.5)
alpha = c(1, 2)
sig2= c(0.1, 0.1)
theta = c(3, 8)
Q = matrix(c(-p.mk[1],p.mk[2],p.mk[1],-p.mk[2]), 2, 2)
theta0 = 5
rate.cat = 1
model.cor = "ER"
model.ou = "OUMA"
data <- OUwie:::hOUwie.sim(phy, Q, root.p, alpha, sig2, theta0, theta)[[1]]
p = c(0.1, 0.01, 0.1, 1, 3, 8)
hOUwie.dat <- OUwie:::organizeHOUwieDat(data)
nObs <- length(hOUwie.dat$ObservedTraits)
model.set.final <- corHMM:::rate.cat.set.corHMM.JDB(phy=phy,data=hOUwie.dat$data.cor,rate.cat=rate.cat, ntraits = nObs, model = model.cor)
phy <- reorder(phy, "pruningwise")
index.ou <- OUwie:::getParamStructure(model.ou, "three.point", FALSE, FALSE, dim(model.set.final$Q)[2])
OUwie:::hOUwie.dev(p = log(p), phy = phy, data.cor = OUwie:::organizeHOUwieDat(data)$data.cor, data.ou = OUwie:::organizeHOUwieDat(data)$data.ou, liks = model.set.final$liks, Q=model.set.final$Q, rate=model.set.final$rate, root.p=root.p, rate.cat=rate.cat, index.ou=index.ou, model.ou=model.ou, nSim=1, nCores=1, algorithm = "three.point")
debug(OUwie:::hOUwie.dev)
OUwie:::hOUwie.dev(p = log(p), phy = phy, data.cor = OUwie:::organizeHOUwieDat(data)$data.cor, data.ou = OUwie:::organizeHOUwieDat(data)$data.ou, liks = model.set.final$liks, Q=model.set.final$Q, rate=model.set.final$rate, root.p=root.p, rate.cat=rate.cat, index.ou=index.ou, model.ou=model.ou, nSim=1, nCores=1, algorithm = "three.point")
INV <- unlist(mclapply(simmap, function(x) OUwie.fixed(x, data.ou, model = model.ou, simmap.tree = TRUE, scaleHeight = FALSE, clade = NULL, alpha = alpha, sigma.sq = sigma.sq, theta = theta, check.identify = FALSE, algorithm = "invert", tip.paths = tip.paths, quiet = TRUE)$loglik, mc.cores = nCores))
TPT <- unlist(mclapply(simmap, function(x) OUwie.fixed(x, data.ou, model = model.ou, simmap.tree = TRUE, scaleHeight = FALSE, clade = NULL, alpha = alpha, sigma.sq = sigma.sq, theta = theta, check.identify = FALSE, algorithm = "three.point", tip.paths = tip.paths, quiet = TRUE)$loglik, mc.cores = nCores))
TPT
INV
TPT
debug(OUwie.fixed)
TPT <- unlist(mclapply(simmap, function(x) OUwie.fixed(x, data.ou, model = model.ou, simmap.tree = TRUE, scaleHeight = FALSE, clade = NULL, alpha = alpha, sigma.sq = sigma.sq, theta = theta, check.identify = FALSE, algorithm = "three.point", tip.paths = tip.paths, quiet = TRUE)$loglik, mc.cores = nCores))
debug(dev.fixed)
fixed.fit <- dev.fixed()
transformed.tree
transformed.tree
tip.paths
transformed.tree <- transformPhy(phy, map, pars, tip.paths)
transformed.tree
transformed.tree$tree$edge.length
debug(transformPhy)
transformed.tree <- transformPhy(phy, map, pars, tip.paths)
NodeAge_i
DistRoot_i
RootAge
Map_i
D
#simplest case
require(OUwie)
require(phylolm)
require(geiger)
data(tworegime)
#Plot the tree and the internal nodes to highlight the selective regimes:
select.reg<-character(length(tree$node.label))
select.reg[tree$node.label == 1] <- "black"
select.reg[tree$node.label == 2] <- "red"
tree$edge.length <- tree$edge.length/max(branching.times(tree))
StdErr <- c(0.0, 0.02, 0.05, 0.1, 0.2, 0.5, 1)
LikRes <- matrix(NA, 3, length(StdErr), dimnames = list(c("Phylolm", "Invert", "3-point"), StdErr))
for(i in 1:length(StdErr)){
PhyloLMDat <- trait[,3]
trait[,4] <- StdErr[i]
names(PhyloLMDat) <- trait[,1]
alpha=c(2, 2)
sigma.sq=c(0.1, 0.1)
theta=c(3, 3)
PLM <- OU1d.loglik(trait=PhyloLMDat, phy=tree, model="OUfixedRoot", parameters=list(ancestral.state=theta[1], alpha=alpha[1],sigma2=sigma.sq[1], optimal.value=theta[1], sigma2_error=StdErr[i]^2))
INV <- OUwie.fixed(tree,trait,model=c("OU1"), simmap.tree=FALSE, scaleHeight=FALSE, mserr = "known", clade=NULL, alpha=alpha,sigma.sq=sigma.sq,theta=theta, algorithm = "invert")$loglik
TPT <- OUwie.fixed(tree,trait,model=c("OU1"), simmap.tree=FALSE, scaleHeight=FALSE, mserr = "known", clade=NULL, alpha=alpha,sigma.sq=sigma.sq,theta=theta, algorithm = "three.point")$loglik
LikRes[,i] <- c(PLM, INV, TPT)
}
LikRes
require(OUwie)
require(phylolm)
require(geiger)
data(tworegime)
#Plot the tree and the internal nodes to highlight the selective regimes:
select.reg<-character(length(tree$node.label))
select.reg[tree$node.label == 1] <- "black"
select.reg[tree$node.label == 2] <- "red"
tree$edge.length <- tree$edge.length/max(branching.times(tree))
StdErr <- c(0.01, 0.02, 0.05, 0.1, 0.2, 0.5, 1)
LikRes <- matrix(NA, 3, length(StdErr), dimnames = list(c("Geiger", "Invert", "3-point"), StdErr))
for(i in 1:length(StdErr)){
PhyloLMDat <- trait[,3]
StdErrG <- abs(rnorm(length(tree$tip.label), mean = StdErr[i], sd = StdErr[i]/10))
trait[,4] <- StdErrG
names(PhyloLMDat) <- trait[,1]
names(StdErrG) <- trait[,1]
fitCon <- fitContinuous(tree, PhyloLMDat, SE = StdErrG, model = "OU")
if(fitCon$opt$alpha > 1e-10){
alpha=c(fitCon$opt$alpha, fitCon$opt$alpha)
}else{
alpha=c(1e-10, 1e-10)
}
sigma.sq=c(fitCon$opt$sigsq, fitCon$opt$sigsq)
theta=c(fitCon$opt$z0, fitCon$opt$z0)
INV <- OUwie.fixed(tree,trait,model=c("OU1"), simmap.tree=FALSE, scaleHeight=FALSE, mserr = "known", clade=NULL, alpha=alpha,sigma.sq=sigma.sq,theta=theta, algorithm = "invert")$loglik
GEI <- fitCon$opt$lnL
TPT <- OUwie.fixed(tree,trait,model=c("OU1"), simmap.tree=FALSE, scaleHeight=FALSE, mserr = "known", clade=NULL, alpha=alpha,sigma.sq=sigma.sq,theta=theta, algorithm = "three.point")$loglik
LikRes[,i] <- c(GEI, INV, TPT)
}
LikRes
require(OUwie)
require(phylolm)
require(geiger)
data(tworegime)
#Plot the tree and the internal nodes to highlight the selective regimes:
select.reg<-character(length(tree$node.label))
select.reg[tree$node.label == 1] <- "black"
select.reg[tree$node.label == 2] <- "red"
tree$edge.length <- tree$edge.length/max(branching.times(tree))
StdErr <- c(0.00, 0.02, 0.05, 0.1, 0.2, 0.5, 1, 2)
LikRes <- matrix(NA, 2, length(StdErr), dimnames = list(c("Invert", "3-point"), StdErr))
for(i in 1:length(StdErr)){
trait[,4] <- abs(rnorm(length(tree$tip.label), mean = StdErr[i], sd = StdErr[i]/10))
alpha=c(1, 2)
sigma.sq=c(1, 2)
theta=c(5, 10)
INV <- OUwie.fixed(tree,trait,model=c("OUMVA"), simmap.tree=FALSE, scaleHeight=FALSE, mserr = "known", clade=NULL, alpha=alpha,sigma.sq=sigma.sq,theta=theta, algorithm = "invert")$loglik
TPT <- OUwie.fixed(tree,trait,model=c("OUMVA"), simmap.tree=FALSE, scaleHeight=FALSE, mserr = "known", clade=NULL, alpha=alpha,sigma.sq=sigma.sq,theta=theta, algorithm = "three.point")$loglik
LikRes[,i] <- c(INV, TPT)
}
LikRes
1/2 * 10 * 1/2
10/4
#simplest case
require(OUwie)
require(phylolm)
require(geiger)
data(tworegime)
#Plot the tree and the internal nodes to highlight the selective regimes:
select.reg<-character(length(tree$node.label))
select.reg[tree$node.label == 1] <- "black"
select.reg[tree$node.label == 2] <- "red"
tree$edge.length <- tree$edge.length/max(branching.times(tree))
StdErr <- c(0.0, 0.02, 0.05, 0.1, 0.2, 0.5, 1)
LikRes <- matrix(NA, 3, length(StdErr), dimnames = list(c("Phylolm", "Invert", "3-point"), StdErr))
for(i in 1:length(StdErr)){
PhyloLMDat <- trait[,3]
trait[,4] <- StdErr[i]
names(PhyloLMDat) <- trait[,1]
alpha=c(2, 2)
sigma.sq=c(0.1, 0.1)
theta=c(3, 3)
PLM <- OU1d.loglik(trait=PhyloLMDat, phy=tree, model="OUfixedRoot", parameters=list(ancestral.state=theta[1], alpha=alpha[1],sigma2=sigma.sq[1], optimal.value=theta[1], sigma2_error=StdErr[i]^2))
INV <- OUwie.fixed(tree,trait,model=c("OU1"), simmap.tree=FALSE, scaleHeight=FALSE, mserr = "known", clade=NULL, alpha=alpha,sigma.sq=sigma.sq,theta=theta, algorithm = "invert")$loglik
TPT <- OUwie.fixed(tree,trait,model=c("OU1"), simmap.tree=FALSE, scaleHeight=FALSE, mserr = "known", clade=NULL, alpha=alpha,sigma.sq=sigma.sq,theta=theta, algorithm = "three.point")$loglik
LikRes[,i] <- c(PLM, INV, TPT)
}
LikRes
require(OUwie)
require(phylolm)
require(geiger)
data(tworegime)
#Plot the tree and the internal nodes to highlight the selective regimes:
select.reg<-character(length(tree$node.label))
select.reg[tree$node.label == 1] <- "black"
select.reg[tree$node.label == 2] <- "red"
tree$edge.length <- tree$edge.length/max(branching.times(tree))
StdErr <- c(0.01, 0.02, 0.05, 0.1, 0.2, 0.5, 1)
LikRes <- matrix(NA, 3, length(StdErr), dimnames = list(c("Geiger", "Invert", "3-point"), StdErr))
for(i in 1:length(StdErr)){
PhyloLMDat <- trait[,3]
StdErrG <- abs(rnorm(length(tree$tip.label), mean = StdErr[i], sd = StdErr[i]/10))
trait[,4] <- StdErrG
names(PhyloLMDat) <- trait[,1]
names(StdErrG) <- trait[,1]
fitCon <- fitContinuous(tree, PhyloLMDat, SE = StdErrG, model = "OU")
if(fitCon$opt$alpha > 1e-10){
alpha=c(fitCon$opt$alpha, fitCon$opt$alpha)
}else{
alpha=c(1e-10, 1e-10)
}
sigma.sq=c(fitCon$opt$sigsq, fitCon$opt$sigsq)
theta=c(fitCon$opt$z0, fitCon$opt$z0)
INV <- OUwie.fixed(tree,trait,model=c("OU1"), simmap.tree=FALSE, scaleHeight=FALSE, mserr = "known", clade=NULL, alpha=alpha,sigma.sq=sigma.sq,theta=theta, algorithm = "invert")$loglik
GEI <- fitCon$opt$lnL
TPT <- OUwie.fixed(tree,trait,model=c("OU1"), simmap.tree=FALSE, scaleHeight=FALSE, mserr = "known", clade=NULL, alpha=alpha,sigma.sq=sigma.sq,theta=theta, algorithm = "three.point")$loglik
LikRes[,i] <- c(GEI, INV, TPT)
}
LikRes
require(OUwie)
require(phylolm)
require(geiger)
data(tworegime)
#Plot the tree and the internal nodes to highlight the selective regimes:
select.reg<-character(length(tree$node.label))
select.reg[tree$node.label == 1] <- "black"
select.reg[tree$node.label == 2] <- "red"
tree$edge.length <- tree$edge.length/max(branching.times(tree))
StdErr <- c(0.00, 0.02, 0.05, 0.1, 0.2, 0.5, 1, 2)
LikRes <- matrix(NA, 2, length(StdErr), dimnames = list(c("Invert", "3-point"), StdErr))
for(i in 1:length(StdErr)){
trait[,4] <- abs(rnorm(length(tree$tip.label), mean = StdErr[i], sd = StdErr[i]/10))
alpha=c(1, 2)
sigma.sq=c(1, 2)
theta=c(5, 10)
INV <- OUwie.fixed(tree,trait,model=c("OUMVA"), simmap.tree=FALSE, scaleHeight=FALSE, mserr = "known", clade=NULL, alpha=alpha,sigma.sq=sigma.sq,theta=theta, algorithm = "invert")$loglik
TPT <- OUwie.fixed(tree,trait,model=c("OUMVA"), simmap.tree=FALSE, scaleHeight=FALSE, mserr = "known", clade=NULL, alpha=alpha,sigma.sq=sigma.sq,theta=theta, algorithm = "three.point")$loglik
LikRes[,i] <- c(INV, TPT)
}
LikRes[,i] <- c(INV, TPT)
LikRes
require(corHMM)
require(OUwie)
require(parallel)
require(geiger)
require(proftools)
phy <- sim.bdtree(b = 1, d = 0.5, stop = "taxa", n = 250)
phy <- drop.extinct(phy)
root.p = c(0.5, 0.5)
p.mk <- c(0.5, 0.5)
alpha = c(1, 2)
sig2= c(0.1, 0.1)
theta = c(3, 8)
Q = matrix(c(-p.mk[1],p.mk[2],p.mk[1],-p.mk[2]), 2, 2)
theta0 = 5
rate.cat = 1
model.cor = "ER"
model.ou = "OUMA"
data <- OUwie:::hOUwie.sim(phy, Q, root.p, alpha, sig2, theta0, theta)[[1]]
p = c(0.1, 0.01, 0.1, 1, 3, 8)
hOUwie.dat <- OUwie:::organizeHOUwieDat(data)
nObs <- length(hOUwie.dat$ObservedTraits)
model.set.final <- corHMM:::rate.cat.set.corHMM.JDB(phy=phy,data=hOUwie.dat$data.cor,rate.cat=rate.cat, ntraits = nObs, model = model.cor)
phy <- reorder(phy, "pruningwise")
index.ou <- OUwie:::getParamStructure(model.ou, "three.point", FALSE, FALSE, dim(model.set.final$Q)[2])
debug(OUwie:::hOUwie.dev)
OUwie:::hOUwie.dev(p = log(p), phy = phy, data.cor = OUwie:::organizeHOUwieDat(data)$data.cor, data.ou = OUwie:::organizeHOUwieDat(data)$data.ou, liks = model.set.final$liks, Q=model.set.final$Q, rate=model.set.final$rate, root.p=root.p, rate.cat=rate.cat, index.ou=index.ou, model.ou=model.ou, nSim=1, nCores=1, algorithm = "three.point")
INV <- unlist(mclapply(simmap, function(x) OUwie.fixed(x, data.ou, model = model.ou, simmap.tree = TRUE, scaleHeight = FALSE, clade = NULL, alpha = alpha, sigma.sq = sigma.sq, theta = theta, check.identify = FALSE, algorithm = "invert", tip.paths = tip.paths, quiet = TRUE)$loglik, mc.cores = nCores))
TPT <- unlist(mclapply(simmap, function(x) OUwie.fixed(x, data.ou, model = model.ou, simmap.tree = TRUE, scaleHeight = FALSE, clade = NULL, alpha = alpha, sigma.sq = sigma.sq, theta = theta, check.identify = FALSE, algorithm = "three.point", tip.paths = tip.paths, quiet = TRUE)$loglik, mc.cores = nCores))
INV
TPT
tre
tree
tree$edge
tmp <- reorder(tree, "pruningwise")
tmp <- reorder(tree, "postorder")
tmp$edge
tmp <- reorder(tree, "preorder")
#simplest case
require(OUwie)
require(phylolm)
require(geiger)
data(tworegime)
#Plot the tree and the internal nodes to highlight the selective regimes:
select.reg<-character(length(tree$node.label))
select.reg[tree$node.label == 1] <- "black"
select.reg[tree$node.label == 2] <- "red"
tree$edge.length <- tree$edge.length/max(branching.times(tree))
StdErr <- c(0.0, 0.02, 0.05, 0.1, 0.2, 0.5, 1)
LikRes <- matrix(NA, 3, length(StdErr), dimnames = list(c("Phylolm", "Invert", "3-point"), StdErr))
for(i in 1:length(StdErr)){
PhyloLMDat <- trait[,3]
trait[,4] <- StdErr[i]
names(PhyloLMDat) <- trait[,1]
alpha=c(2, 2)
sigma.sq=c(0.1, 0.1)
theta=c(3, 3)
PLM <- OU1d.loglik(trait=PhyloLMDat, phy=tree, model="OUfixedRoot", parameters=list(ancestral.state=theta[1], alpha=alpha[1],sigma2=sigma.sq[1], optimal.value=theta[1], sigma2_error=StdErr[i]^2))
INV <- OUwie.fixed(tree,trait,model=c("OU1"), simmap.tree=FALSE, scaleHeight=FALSE, mserr = "known", clade=NULL, alpha=alpha,sigma.sq=sigma.sq,theta=theta, algorithm = "invert")$loglik
TPT <- OUwie.fixed(tree,trait,model=c("OU1"), simmap.tree=FALSE, scaleHeight=FALSE, mserr = "known", clade=NULL, alpha=alpha,sigma.sq=sigma.sq,theta=theta, algorithm = "three.point")$loglik
LikRes[,i] <- c(PLM, INV, TPT)
}
LikRes
require(OUwie)
require(phylolm)
require(geiger)
data(tworegime)
#Plot the tree and the internal nodes to highlight the selective regimes:
select.reg<-character(length(tree$node.label))
select.reg[tree$node.label == 1] <- "black"
select.reg[tree$node.label == 2] <- "red"
tree$edge.length <- tree$edge.length/max(branching.times(tree))
StdErr <- c(0.01, 0.02, 0.05, 0.1, 0.2, 0.5, 1)
LikRes <- matrix(NA, 3, length(StdErr), dimnames = list(c("Geiger", "Invert", "3-point"), StdErr))
for(i in 1:length(StdErr)){
PhyloLMDat <- trait[,3]
StdErrG <- abs(rnorm(length(tree$tip.label), mean = StdErr[i], sd = StdErr[i]/10))
trait[,4] <- StdErrG
names(PhyloLMDat) <- trait[,1]
names(StdErrG) <- trait[,1]
fitCon <- fitContinuous(tree, PhyloLMDat, SE = StdErrG, model = "OU")
if(fitCon$opt$alpha > 1e-10){
alpha=c(fitCon$opt$alpha, fitCon$opt$alpha)
}else{
alpha=c(1e-10, 1e-10)
}
sigma.sq=c(fitCon$opt$sigsq, fitCon$opt$sigsq)
theta=c(fitCon$opt$z0, fitCon$opt$z0)
INV <- OUwie.fixed(tree,trait,model=c("OU1"), simmap.tree=FALSE, scaleHeight=FALSE, mserr = "known", clade=NULL, alpha=alpha,sigma.sq=sigma.sq,theta=theta, algorithm = "invert")$loglik
GEI <- fitCon$opt$lnL
TPT <- OUwie.fixed(tree,trait,model=c("OU1"), simmap.tree=FALSE, scaleHeight=FALSE, mserr = "known", clade=NULL, alpha=alpha,sigma.sq=sigma.sq,theta=theta, algorithm = "three.point")$loglik
LikRes[,i] <- c(GEI, INV, TPT)
}
LikRes
require(OUwie)
require(phylolm)
require(geiger)
data(tworegime)
#Plot the tree and the internal nodes to highlight the selective regimes:
select.reg<-character(length(tree$node.label))
select.reg[tree$node.label == 1] <- "black"
select.reg[tree$node.label == 2] <- "red"
tree$edge.length <- tree$edge.length/max(branching.times(tree))
StdErr <- c(0.00, 0.02, 0.05, 0.1, 0.2, 0.5, 1, 2)
LikRes <- matrix(NA, 2, length(StdErr), dimnames = list(c("Invert", "3-point"), StdErr))
for(i in 1:length(StdErr)){
trait[,4] <- abs(rnorm(length(tree$tip.label), mean = StdErr[i], sd = StdErr[i]/10))
alpha=c(1, 2)
sigma.sq=c(1, 2)
theta=c(5, 10)
INV <- OUwie.fixed(tree,trait,model=c("OUMVA"), simmap.tree=FALSE, scaleHeight=FALSE, mserr = "known", clade=NULL, alpha=alpha,sigma.sq=sigma.sq,theta=theta, algorithm = "invert")$loglik
TPT <- OUwie.fixed(tree,trait,model=c("OUMVA"), simmap.tree=FALSE, scaleHeight=FALSE, mserr = "known", clade=NULL, alpha=alpha,sigma.sq=sigma.sq,theta=theta, algorithm = "three.point")$loglik
LikRes[,i] <- c(INV, TPT)
}
LikRes
data(tworegime)
set.seed(42)
sigma.sq=c(0.4669113, 0.4669113)
theta=c(1.326483, 1.326483)
BM1Invert <- OUwie.fixed(tree, trait, model=c("BM1"), simmap.tree=FALSE, scaleHeight=TRUE, clade=NULL, sigma.sq=sigma.sq, shift.point=0.5, algorithm="invert")
BM13Point <- OUwie.fixed(tree, trait, model=c("BM1"), simmap.tree=FALSE, scaleHeight=TRUE, clade=NULL, sigma.sq=sigma.sq, theta=theta, shift.point=0.5, algorithm="three.point")
comparison <- identical(round(as.numeric(BM1Invert$loglik),5), round(as.numeric(BM13Point$loglik),5))
comparison
data(tworegime)
set.seed(42)
sigma.sq=c(0.2424788, 0.7007112)
theta <- c(1.4719377, 1.4719377)
BMSInvert <- OUwie.fixed(tree, trait, model=c("BMS"), simmap.tree=FALSE, scaleHeight=TRUE, clade=NULL, sigma.sq=sigma.sq, shift.point=0.5, algorithm="invert")
BMS3Point <- OUwie.fixed(tree, trait, model=c("BM1"), simmap.tree=FALSE, scaleHeight=TRUE, clade=NULL, sigma.sq=sigma.sq, theta=theta, shift.point=0.5, algorithm="three.point")
comparison <- identical(round(as.numeric(BMSInvert$loglik),5), round(as.numeric(BMS3Point$loglik),5))
comparison
data(tworegime)
set.seed(42)
alpha=c(0.358939, 0.3589399)
sigma.sq=c(0.5197486, 0.5197486)
theta=c( 1.3301447, 1.3301447)
OU1Invert <- OUwie.fixed(tree, trait, model=c("OU1"), simmap.tree=FALSE, scaleHeight=TRUE, clade=NULL, alpha=alpha, sigma.sq=sigma.sq,theta=theta, shift.point=0.5, algorithm="invert")
OU13Point <- OUwie.fixed(tree, trait, model=c("OU1"), simmap.tree=FALSE, scaleHeight=TRUE, clade=NULL, alpha=alpha, sigma.sq=sigma.sq,theta=theta, shift.point=0.5, algorithm="three.point")
comparison <- identical(round(as.numeric(OU1Invert$loglik),5), round(as.numeric(OU13Point$loglik),5))
OU13Point
comparison
data(tworegime)
set.seed(42)
alpha=c(1.3916589, 1.3916589)
sigma.sq=c(0.6545502, 0.6545502)
theta=c(1.6751330, 0.4424138)
OUMInvert <- OUwie.fixed(tree, trait, model=c("OUM"), simmap.tree=FALSE, scaleHeight=TRUE, clade=NULL, alpha=alpha, sigma.sq=sigma.sq,theta=theta, shift.point=0.5, algorithm="invert")
OUM3Point <- OUwie.fixed(tree, trait, model=c("OUM"), simmap.tree=FALSE, scaleHeight=TRUE, clade=NULL, alpha=alpha, sigma.sq=sigma.sq,theta=theta, shift.point=0.5, algorithm="three.point")
comparison <- identical(round(as.numeric(OUMInvert$loglik),5), round(as.numeric(OUM3Point$loglik),5))
comparison
data(tworegime)
set.seed(42)
alpha=c(1.7110818, 1.711082)
sigma.sq=c(0.3517019, 1.076479)
theta=c(1.676894, 0.5563541)
OUMVInvert <- OUwie.fixed(tree, trait, model=c("OUMV"), simmap.tree=FALSE, scaleHeight=TRUE, clade=NULL, alpha=alpha, sigma.sq=sigma.sq,theta=theta, shift.point=0.5, algorithm="invert")
OUMV3Point <- OUwie.fixed(tree, trait, model=c("OUMV"), simmap.tree=FALSE, scaleHeight=TRUE, clade=NULL, alpha=alpha, sigma.sq=sigma.sq,theta=theta, shift.point=0.5, algorithm="three.point")
comparison <- identical(round(as.numeric(OUMVInvert$loglik),5), round(as.numeric(OUMV3Point$loglik),5))
comparison
data(tworegime)
set.seed(42)
alpha=c(1.6501816, 1.0294487)
sigma.sq=c(0.7082462, 0.7082462)
theta=c(1.6765718, 0.1516105)
OUMAInvert <- OUwie.fixed(tree, trait, model=c("OUMA"), simmap.tree=FALSE, scaleHeight=TRUE, clade=NULL, alpha=alpha, sigma.sq=sigma.sq,theta=theta, shift.point=0.5, algorithm="invert")
OUMA3Point <- OUwie.fixed(tree, trait, model=c("OUMA"), simmap.tree=FALSE, scaleHeight=TRUE, clade=NULL, alpha=alpha, sigma.sq=sigma.sq,theta=theta, shift.point=0.5, algorithm="three.point")
comparison <- identical(round(as.numeric(OUMAInvert$loglik),5), round(as.numeric(OUMA3Point$loglik),5))
comparison
data(tworegime)
set.seed(42)
alpha=c(3.0793193, 0.6060786)
sigma.sq=c(0.4735485, 1.7049102)
theta=c(1.68189033, -1.032546)
OUMVAInvert <- OUwie.fixed(tree, trait, model=c("OUMVA"), simmap.tree=FALSE, scaleHeight=TRUE, clade=NULL, alpha=alpha, sigma.sq=sigma.sq,theta=theta, shift.point=0.5, algorithm="invert")
OUMVA3Point <- OUwie.fixed(tree, trait, model=c("OUMVA"), simmap.tree=FALSE, scaleHeight=TRUE, clade=NULL, alpha=alpha, sigma.sq=sigma.sq,theta=theta, shift.point=0.5, algorithm="three.point")
comparison <- identical(round(as.numeric(OUMVAInvert$loglik),5), round(as.numeric(OUMVA3Point$loglik),5))
comparison
data(tworegime)
set.seed(42)
ouwiefit <- OUwie(tree, trait, model="BM1", scaleHeight=TRUE, root.station=FALSE, shift.point=0.5, algorithm="three.point", quiet=TRUE)
comparison <- identical(round(ouwiefit$loglik,5), round(-21.95911, 5))
comparison
data(tworegime)
set.seed(42)
ouwiefit <- OUwie(tree, trait, model="BM1", scaleHeight=TRUE, root.station=FALSE, shift.point=0.5, algorithm="three.point", quiet=TRUE)
ouwiefit
debug(OUwie)
ouwiefit <- OUwie(tree, trait, model="BM1", scaleHeight=TRUE, root.station=FALSE, shift.point=0.5, algorithm="three.point", quiet=TRUE)
tip.paths
out
debug(dev)
out = nloptr(x0 = log(ip), eval_f = dev, lb = lower,
ub = upper, opts = opts, index.mat = index.mat,
edges = edges, mserr = mserr, trendy = trendy, get.root.theta = get.root.theta)
pars
theta0
root.par.index
expected.vals
transformed.tree
mserr
tip.paths
debug(transformPhy)
transformed.tree <- transformPhy(phy, map, pars,
tip.paths)
V_Tilde
DiagWt
tip.paths
D
exp(-sum(D[tip.paths[[i]]]))
sum(D[tip.paths[[i]]]
)
exp(-sum(D[tip.paths[[i]]]))
exp(-sum(D[tip.paths[[i]]]))
sum(D[tip.paths[[i]]])
exp(-sum(D[tip.paths[[i]]]))
comp
phylolm::three.point.compute(transformed.tree,
x, expected.vals, transformed.tree$diag)
require(OUwie)
set.seed(42)
ouwiefit <- OUwie(tree, trait, model="OUMA", scaleHeight=TRUE, root.station=FALSE, shift.point=0.5, algorithm="three.point", quiet=TRUE)
data(tworegime)
set.seed(42)
ouwiefit <- OUwie(tree, trait, model="OUMA", scaleHeight=TRUE, root.station=FALSE, shift.point=0.5, algorithm="three.point", quiet=TRUE)
comparison <- identical(round(ouwiefit$loglik,3), round(-19.42678,3))
comparison
ouwiefit <- OUwie(tree, trait, model="OUMA", scaleHeight=FALSE, root.station=FALSE, shift.point=0.5, algorithm="three.point", quiet=TRUE)
ouwiefit
require(OUwie)
data(tworegime)
set.seed(42)
ouwiefit <- OUwie(tree, trait, model="OUMA", scaleHeight=FALSE, root.station=FALSE, shift.point=0.5, algorithm="three.point", quiet=TRUE)
comparison
comparison <- identical(round(ouwiefit$loglik,3), round(-19.42678,3))
comparison
require(OUwie)
?OUwie
OUwie(tree,trait,model=c("OUMV"))
data(tworegime)
#Plot the tree and the internal nodes to highlight the selective regimes:
select.reg<-character(length(tree$node.label))
select.reg[tree$node.label == 1] <- "black"
select.reg[tree$node.label == 2] <- "red"
OUwie(tree,trait,model=c("BMS"))
install.packages("OUwie")
require(OUwie)
data(tworegime)
select.reg<-character(length(tree$node.label))
select.reg[tree$node.label == 1] <- "black"
select.reg[tree$node.label == 2] <- "red"
OUwie(tree,trait,model=c("BMS"))
debug(OUwie)
OUwie(tree,trait,model=c("BMS"))
param.count
index.mat
ip
debug(dev)
p
W
DET
varcov.ou
Rate.mat
index.mat
Rate.mat
OUwie(tree,trait,model=c("BMS"))
index.mat
debug(dev)
index.mat
Rate.mat
Rate.mat
index.mat
OUwie(tree,trait,model=c("BMS"))
Rate.mat
data(tworegime)
#Plot the tree and the internal nodes to highlight the selective regimes:
select.reg<-character(length(tree$node.label))
select.reg[tree$node.label == 1] <- "black"
select.reg[tree$node.label == 2] <- "red"
require(OUwie)
data(tworegime)
#Plot the tree and the internal nodes to highlight the selective regimes:
select.reg<-character(length(tree$node.label))
select.reg[tree$node.label == 1] <- "black"
select.reg[tree$node.label == 2] <- "red"
OUwie(tree,trait,model=c("BMS"))
OUwie(tree,trait,model=c("BMS"), algorithm = "three.point")
setwd("2021_SeedDispersal/")
load("res_ouwie/Ericaceae-dat.prec.se-21_01_27-OURes.Rsave")
obj_j
obj_j$OUMA_prec[[1]]
obj_j$OUMA_prec[[1]]$data
