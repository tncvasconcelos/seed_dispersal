comparison
library(testthat)
library(OUwie)
data(tworegime)
set.seed(42)
ouwiefit <- OUwie(tree, trait, model="BMS", scaleHeight=TRUE, root.station=FALSE, shift.point=0.5, algorithm="three.point", quiet=TRUE)
comparison <- identical(round(ouwiefit$loglik,3), round(-17.85074,3))
expect_true(comparison)
ouwiefit
comparison
ouwiefit
debug(OUwie)
ouwiefit <- OUwie(tree, trait, model="BMS", scaleHeight=TRUE, root.station=FALSE, shift.point=0.5, algorithm="three.point", quiet=TRUE)
debug(dev)
pars
transformed.tree
library(testthat)
library(OUwie)
data(tworegime)
set.seed(42)
ouwiefit <- OUwie(tree, trait, model="BM1", scaleHeight=TRUE, root.station=FALSE, shift.point=0.5, algorithm="three.point", quiet=TRUE)
comparison <- identical(round(ouwiefit$loglik,3), round(-21.95911,3))
expect_true(comparison)
comparison
comparison
ouwiefit
ouwiefit <- OUwie(tree, trait, model="BM1", scaleHeight=TRUE, root.station=FALSE, shift.point=0.5, algorithm="three.point", quiet=TRUE)
comparison <- identical(round(ouwiefit$loglik,5), round(-21.95911, 5))
expect_true(comparison)
data(tworegime)
set.seed(42)
ouwiefit <- OUwie(tree, trait, model="BMS", scaleHeight=TRUE, root.station=FALSE, shift.point=0.5, algorithm="three.point", quiet=TRUE)
comparison <- identical(round(ouwiefit$loglik,5), round(-17.85074,5))
expect_true(comparison)
comparison
data(tworegime)
set.seed(42)
ouwiefit <- OUwie(tree, trait, model="OU1", scaleHeight=TRUE, root.station=FALSE, shift.point=0.5, algorithm="three.point", quiet=TRUE)
comparison <- identical(round(ouwiefit$loglik,3), round(-21.74538,3))
expect_true(comparison)
data(tworegime)
set.seed(42)
ouwiefit <- OUwie(tree, trait, model="OUM", scaleHeight=TRUE, root.station=FALSE, shift.point=0.5, algorithm="three.point", quiet=TRUE)
comparison <- identical(round(ouwiefit$loglik,3), round(-19.51388,3))
comparison <- identical(round(ouwiefit$loglik,5), round(-19.51388,5))
expect_true(comparison)
ouwiefit
ouwiefit <- OUwie(tree, trait, model="OUM", scaleHeight=TRUE, root.station=FALSE, shift.point=0.5, algorithm="three.point", quiet=TRUE)
comparison <- identical(round(ouwiefit$loglik,3), round(-19.51388,3))
expect_true(comparison)
data(tworegime)
set.seed(42)
ouwiefit <- OUwie(tree, trait, model="OUMV", scaleHeight=TRUE, root.station=FALSE, shift.point=0.5, algorithm="three.point", quiet=TRUE)
comparison <- identical(round(ouwiefit$loglik,3), round(-14.79506,3))
expect_true(comparison)
comparison
data(tworegime)
set.seed(42)
ouwiefit <- OUwie(tree, trait, model="OUMA", scaleHeight=TRUE, root.station=FALSE, shift.point=0.5, algorithm="three.point", quiet=TRUE)
comparison <- identical(round(ouwiefit$loglik,3), round(-19.42678,3))
expect_true(comparison)
comparison
data(tworegime)
set.seed(42)
ouwiefit <- OUwie(tree, trait, model="OUMVA", scaleHeight=TRUE, root.station=FALSE, shift.point=0.5, algorithm="three.point", quiet=TRUE)
comparison <- identical(round(ouwiefit$loglik,3), round(-14.03592,3))
expect_true(comparison)
comparison
require(OUwie)
require(phylolm)
require(geiger)
data(tworegime)
#Plot the tree and the internal nodes to highlight the selective regimes:
select.reg<-character(length(tree$node.label))
select.reg[tree$node.label == 1] <- "black"
select.reg[tree$node.label == 2] <- "red"
StdErr <- c(0.01, 0.02, 0.05, 0.1, 0.2, 0.5, 1, 2)
LikRes <- matrix(NA, 2, length(StdErr), dimnames = list(c("Invert", "3-point"), StdErr))
for(i in 1:length(StdErr)){
trait[,4] <- abs(rnorm(length(tree$tip.label), mean = StdErr[i], sd = StdErr[i]/10))
alpha=c(5, 10)
sigma.sq=c(1, 2)
theta=c(5, 10)
INV <- OUwie.fixed(tree,trait,model=c("OUMVA"), simmap.tree=FALSE, scaleHeight=FALSE, mserr = "known", clade=NULL, alpha=alpha,sigma.sq=sigma.sq,theta=theta, algorithm = "invert")$loglik
TPT <- OUwie.fixed(tree,trait,model=c("OUMVA"), simmap.tree=FALSE, scaleHeight=FALSE, mserr = "known", clade=NULL, alpha=alpha,sigma.sq=sigma.sq,theta=theta, algorithm = "three.point")$loglik
LikRes[,i] <- c(INV, TPT)
}
LikRes
LikRes
apply(LikRes, 2, function(x) identical(x[1], x[2]))
apply(LikRes, 2, function(x) identical(round(x[1], 3), round(x[2], 3)))
apply(LikRes, 2, function(x) x[1] - x[2])
apply(LikRes, 2, function(x) identical(round(x[1], 2), round(x[2], 2)))
apply(LikRes, 2, function(x) identical(round(x[1], 1), round(x[2], 1)))
apply(LikRes, 2, function(x) identical(round(x[1]), round(x[2])))
LikRes
data(tworegime)
select.reg<-character(length(tree$node.label))
select.reg[tree$node.label == 1] <- "black"
select.reg[tree$node.label == 2] <- "red"
StdErr <- c(0.01, 0.02, 0.05, 0.1, 0.2, 0.5, 1, 2)
LikRes <- numeric(length(StdErr))
tree$edge.length <- tree$edge.length/max(branching.times(tree))
for(i in 1:length(StdErr)){
trait[,4] <- abs(rnorm(length(tree$tip.label), mean = StdErr[i], sd = StdErr[i]/10))
alpha=c(5, 10)
sigma.sq=c(1, 2)
theta=c(5, 10)
INV <- OUwie.fixed(tree,trait,model=c("OUMVA"), simmap.tree=FALSE, scaleHeight=FALSE, mserr = "known", clade=NULL, alpha=alpha,sigma.sq=sigma.sq,theta=theta, algorithm = "invert")$loglik
TPT <- OUwie.fixed(tree,trait,model=c("OUMVA"), simmap.tree=FALSE, scaleHeight=FALSE, mserr = "known", clade=NULL, alpha=alpha,sigma.sq=sigma.sq,theta=theta, algorithm = "three.point")$loglik
LikRes[,i] <- identical(round(INV, 3), round(TPT, 3))
}
LikRes <- numeric(length(StdErr))
tree$edge.length <- tree$edge.length/max(branching.times(tree))
for(i in 1:length(StdErr)){
trait[,4] <- abs(rnorm(length(tree$tip.label), mean = StdErr[i], sd = StdErr[i]/10))
alpha=c(5, 10)
sigma.sq=c(1, 2)
theta=c(5, 10)
INV <- OUwie.fixed(tree,trait,model=c("OUMVA"), simmap.tree=FALSE, scaleHeight=FALSE, mserr = "known", clade=NULL, alpha=alpha,sigma.sq=sigma.sq,theta=theta, algorithm = "invert")$loglik
TPT <- OUwie.fixed(tree,trait,model=c("OUMVA"), simmap.tree=FALSE, scaleHeight=FALSE, mserr = "known", clade=NULL, alpha=alpha,sigma.sq=sigma.sq,theta=theta, algorithm = "three.point")$loglik
LikRes[i] <- identical(round(INV, 3), round(TPT, 3))
}
LikRes
LikRes[i] <- identical
identical(round(INV, 3), round(TPT, 3))
data(tworegime)
set.seed(42)
ouwiefit <- OUwie(tree, trait, model="OUMV", scaleHeight=TRUE, root.station=FALSE, shift.point=0.5, algorithm="three.point", quiet=TRUE)
comparison <- identical(round(ouwiefit$loglik,3), round(-14.79506,3))
expect_true(comparison)
})
test_that("testing OUMA three-point likelihood", {
skip_on_cran()
data(tworegime)
set.seed(42)
ouwiefit <- OUwie(tree, trait, model="OUMA", scaleHeight=TRUE, root.station=FALSE, shift.point=0.5, algorithm="three.point", quiet=TRUE)
comparison <- identical(round(ouwiefit$loglik,3), round(-19.42678,3))
expect_true(comparison)
round(ouwiefit$loglik,3)
round(ouwiefit$loglik,3)
identical(round(ouwiefit$loglik,3), round(-19.42678,3))
comparison <- identical(round(ouwiefit$loglik,3), round(-19.42678,3))
expect_true(comparison)
data(tworegime)
set.seed(42)
ouwiefit <- OUwie(tree, trait, model="OUMA", scaleHeight=TRUE, root.station=FALSE, shift.point=0.5, algorithm="three.point", quiet=TRUE)
comparison <- identical(round(ouwiefit$loglik,3), round(-19.42678,3))
expect_true(comparison)
round(ouwiefit$loglik,3)
round(-19.42678,3)
data(tworegime)
select.reg<-character(length(tree$node.label))
select.reg[tree$node.label == 1] <- "black"
select.reg[tree$node.label == 2] <- "red"
StdErr <- c(0.01, 0.02, 0.05, 0.1, 0.2, 0.5, 1, 2)
LikRes <- numeric(length(StdErr))
i = 1
trait[,4] <- abs(rnorm(length(tree$tip.label), mean = StdErr[i], sd = StdErr[i]/10))
alpha=c(5, 10)
sigma.sq=c(1, 2)
theta=c(5, 10)
INV <- OUwie.fixed(tree,trait,model=c("OUMVA"), simmap.tree=FALSE, scaleHeight=FALSE, mserr = "known", clade=NULL, alpha=alpha,sigma.sq=sigma.sq,theta=theta, algorithm = "invert")$loglik
TPT <- OUwie.fixed(tree,trait,model=c("OUMVA"), simmap.tree=FALSE, scaleHeight=FALSE, mserr = "known", clade=NULL, alpha=alpha,sigma.sq=sigma.sq,theta=theta, algorithm = "three.point")$loglik
INV <- OUwie.fixed(tree,trait,model=c("OUMVA"), simmap.tree=FALSE, scaleHeight=FALSE, mserr = "known", clade=NULL, alpha=alpha,sigma.sq=sigma.sq,theta=theta, algorithm = "invert", quiet=TRUE)$loglik
TPT <- OUwie.fixed(tree,trait,model=c("OUMVA"), simmap.tree=FALSE, scaleHeight=FALSE, mserr = "known", clade=NULL, alpha=alpha,sigma.sq=sigma.sq,theta=theta, algorithm = "three.point", quiet=TRUE)$loglik
TPT
INV
INV <- c(OUwie.fixed(tree,trait,model=c("OUMVA"), simmap.tree=FALSE, scaleHeight=FALSE, mserr = "known", clade=NULL, alpha=alpha,sigma.sq=sigma.sq,theta=theta, algorithm = "invert", quiet=TRUE)$loglik)
INV
identical(round(INV, 3), round(TPT, 3))
LikRes[i] <- identical(round(INV, 5), round(TPT, 5))
LikRes
identical(round(INV, 5), round(TPT, 5))
round(INV, 5)
round(TPT, 5)
identical(round(INV, 5), round(TPT, 5))
data(tworegime)
trait[,4] <- abs(rnorm(length(tree$tip.label), mean = 1, sd = 1/10))
alpha=c(5, 10)
sigma.sq=c(1, 2)
theta=c(5, 10)
INV <- c(OUwie.fixed(tree,trait,model=c("OUMVA"), simmap.tree=FALSE, scaleHeight=FALSE, mserr = "known", clade=NULL, alpha=alpha,sigma.sq=sigma.sq,theta=theta, algorithm = "invert", quiet=TRUE)$loglik)
TPT <- OUwie.fixed(tree,trait,model=c("OUMVA"), simmap.tree=FALSE, scaleHeight=FALSE, mserr = "known", clade=NULL, alpha=alpha,sigma.sq=sigma.sq,theta=theta, algorithm = "three.point", quiet=TRUE)$loglik
identical(round(INV, 5), round(TPT, 5))
comparison <- identical(round(INV, 5), round(TPT, 5))
expect_true(comparison)
#simplest case
require(OUwie)
require(phylolm)
require(geiger)
data(tworegime)
#Plot the tree and the internal nodes to highlight the selective regimes:
select.reg<-character(length(tree$node.label))
select.reg[tree$node.label == 1] <- "black"
select.reg[tree$node.label == 2] <- "red"
StdErr <- c(0.01, 0.02, 0.05, 0.1, 0.2, 0.5, 1)
LikRes <- matrix(NA, 4, length(StdErr), dimnames = list(c("Phylolm", "Geiger", "Invert", "3-point"), StdErr))
for(i in 1:length(StdErr)){
PhyloLMDat <- trait[,3]
trait[,4] <- StdErr[i]
names(PhyloLMDat) <- trait[,1]
fitCon <- fitContinuous(tree, PhyloLMDat, SE = StdErr[i], model = "OU")
if(fitCon$opt$alpha > 1e-10){
alpha=c(fitCon$opt$alpha, fitCon$opt$alpha)
}else{
alpha=c(1e-10, 1e-10)
}
sigma.sq=c(fitCon$opt$sigsq, fitCon$opt$sigsq)
theta=c(fitCon$opt$z0, fitCon$opt$z0)
PLM <- OU1d.loglik(trait=PhyloLMDat, phy=tree, model="OUfixedRoot", parameters=list(ancestral.state=theta[1], alpha=alpha[1],sigma2=sigma.sq[1], optimal.value=theta[1], sigma2_error=StdErr[i]^2))
GEI <- fitCon$opt$lnL
INV <- OUwie.fixed(tree,trait,model=c("OU1"), simmap.tree=FALSE, scaleHeight=FALSE, mserr = "known", clade=NULL, alpha=alpha,sigma.sq=sigma.sq,theta=theta, algorithm = "invert")$loglik
TPT <- OUwie.fixed(tree,trait,model=c("OU1"), simmap.tree=FALSE, scaleHeight=FALSE, mserr = "known", clade=NULL, alpha=alpha,sigma.sq=sigma.sq,theta=theta, algorithm = "three.point")$loglik
LikRes[,i] <- c(PLM, GEI, INV, TPT)
}
LikRes
require(OUwie)
require(phylolm)
require(geiger)
data(tworegime)
#Plot the tree and the internal nodes to highlight the selective regimes:
select.reg<-character(length(tree$node.label))
select.reg[tree$node.label == 1] <- "black"
select.reg[tree$node.label == 2] <- "red"
StdErr <- c(0.01, 0.02, 0.05, 0.1, 0.2, 0.5, 1)
LikRes <- matrix(NA, 3, length(StdErr), dimnames = list(c("Geiger", "Invert", "3-point"), StdErr))
for(i in 1:length(StdErr)){
PhyloLMDat <- trait[,3]
StdErrG <- abs(rnorm(length(tree$tip.label), mean = StdErr[i], sd = StdErr[i]/10))
trait[,4] <- StdErrG
names(PhyloLMDat) <- trait[,1]
names(StdErrG) <- trait[,1]
fitCon <- fitContinuous(tree, PhyloLMDat, SE = StdErrG, model = "OU")
if(fitCon$opt$alpha > 1e-10){
alpha=c(fitCon$opt$alpha, fitCon$opt$alpha)
}else{
alpha=c(1e-10, 1e-10)
}
sigma.sq=c(fitCon$opt$sigsq, fitCon$opt$sigsq)
theta=c(fitCon$opt$z0, fitCon$opt$z0)
INV <- OUwie.fixed(tree,trait,model=c("OU1"), simmap.tree=FALSE, scaleHeight=FALSE, mserr = "known", clade=NULL, alpha=alpha,sigma.sq=sigma.sq,theta=theta, algorithm = "invert")$loglik
GEI <- fitCon$opt$lnL
TPT <- OUwie.fixed(tree,trait,model=c("OU1"), simmap.tree=FALSE, scaleHeight=FALSE, mserr = "known", clade=NULL, alpha=alpha,sigma.sq=sigma.sq,theta=theta, algorithm = "three.point")$loglik
LikRes[,i] <- c(GEI, INV, TPT)
}
require(OUwie)
require(phylolm)
require(geiger)
data(tworegime)
#Plot the tree and the internal nodes to highlight the selective regimes:
select.reg<-character(length(tree$node.label))
select.reg[tree$node.label == 1] <- "black"
select.reg[tree$node.label == 2] <- "red"
StdErr <- c(0.01, 0.02, 0.05, 0.1, 0.2, 0.5, 1, 2)
LikRes <- matrix(NA, 2, length(StdErr), dimnames = list(c("Invert", "3-point"), StdErr))
for(i in 1:length(StdErr)){
trait[,4] <- abs(rnorm(length(tree$tip.label), mean = StdErr[i], sd = StdErr[i]/10))
alpha=c(5, 10)
sigma.sq=c(1, 2)
theta=c(5, 10)
INV <- OUwie.fixed(tree,trait,model=c("OUMVA"), simmap.tree=FALSE, scaleHeight=FALSE, mserr = "known", clade=NULL, alpha=alpha,sigma.sq=sigma.sq,theta=theta, algorithm = "invert")$loglik
TPT <- OUwie.fixed(tree,trait,model=c("OUMVA"), simmap.tree=FALSE, scaleHeight=FALSE, mserr = "known", clade=NULL, alpha=alpha,sigma.sq=sigma.sq,theta=theta, algorithm = "three.point")$loglik
LikRes[,i] <- c(INV, TPT)
}
-142.7562
LikRes
data(tworegime)
set.seed(8)
library(phytools)
regs <- setNames(trait[,2], trait[,1])
test <- make.simmap(tree, regs, model="ER")
for(i in 1:dim(test$mapped.edge)[1]){
entries <- test$mapped.edge[i,which(test$mapped.edge[i,] > 0)]
test$mapped.edge[i,which(test$mapped.edge[i,] > 0)] <- sum(entries)/length(entries)
maps <- test$maps[[i]]
test$maps[[i]] <- rep(sum(maps)/length(maps), length(maps))
names(test$maps[[i]]) <- names(maps)
}
ouwiefit.nodes <- OUwie(tree, trait, model="OUM", root.station=FALSE, shift.point=0.5, algorithm="invert", quiet=TRUE)
ouwiefit.simmap <- OUwie(test, trait, model="OUM", simmap.tree=TRUE, root.station=FALSE, algorithm="invert", shift.point=0.5, quiet=TRUE)
ouwiefit.simmap
ouwiefit.nodes
ouwiefit.simmap <- OUwie(test, trait, model="OUM", simmap.tree=TRUE, root.station=FALSE, algorithm="three.point", shift.point=0.5, quiet=TRUE)
ouwiefit.simmap
ouwiefit.nodes
entries
library(rvest)
library(httr)
library(stringr)
getRandomArticle <- function(){
RandomArticle <- read_html("https://en.wikipedia.org/wiki/Special:Random")
ArticleContent <- html_nodes(RandomArticle, "#mw-content-text p")
ArticleText <- html_text(ArticleContent)
ArticleText <- str_flatten(ArticleText)
ArticleText <- gsub("\n", "", ArticleText)
return(ArticleText)
}
getCurrentStringPosition <- function(CurrentString){
ArticleText <- getRandomArticle()
StringPosition <- str_locate_all(ArticleText, CurrentString)[[1]]
if(dim(StringPosition)[1] < 1){
repeat{
ArticleText <- getRandomArticle()
StringPosition <- str_locate_all(ArticleText, CurrentString)[[1]]
if(dim(StringPosition)[1] > 1) {break}
}
}
return(list(CurrentString = CurrentString, ArticleText = ArticleText, StringPosition = StringPosition))
}
getNextLetter <- function(CurrentString, StringPosition, ArticleText){
NextLetter <- str_sub(ArticleText, StringPosition[dim(StringPosition)[1],1]+1, StringPosition[dim(StringPosition)[1],2]+1)
if(!any(NextLetter == c(letters, " ")) & dim(StringPosition)[1] > 1){
for(i in dim(StringPosition)[1]:2){
NextLetter <- str_sub(ArticleText, StringPosition[i,2]+1, StringPosition[i,2]+1)
if(any(NextLetter == c(letters, " "))) {break}
}
if(i == dim(StringPosition)[1] & !any(NextLetter == c(letters, " "))){
StringSearch <- getCurrentStringPosition(CurrentString)
getNextLetter(StringSearch$CurrentString, StringSearch$StringPosition, StringSearch$ArticleText)
}
}
return(NextLetter)
}
GenerateWords<- function(Order, n){
EnglishLetterFreq <- c(0.0575, 0.0128, 0.0263, 0.0285, 0.0913, 0.0173, 0.0133, 0.0313, 0.0599, 0.0006, 0.0084, 0.0335, 0.0235, 0.0596, 0.0689, 0.0192, 0.0008, 0.0508, 0.0567, 0.0706, 0.0334, 0.0069, 0.0119, 0.0073, 0.0164, 0.0007, 0.1928)
if(Order == 1){
res <- c(letters, " ")[sample(1:27, size = n, replace = TRUE, prob = EnglishLetterFreq)]
res <- str_flatten(res)
return(res)
}
#if(Order > 5){
#  return("Bruh, chill.")
#}
res <- CurrentString <- c(letters, " ")[sample(1:27, size = 1, prob = EnglishLetterFreq)]
repeat{
StringSearch <- getCurrentStringPosition(CurrentString)
NextLetter <- getNextLetter(StringSearch$CurrentString, StringSearch$StringPosition, StringSearch$ArticleText)
if(NextLetter == " "){
CurrentString <- c(letters, " ")[sample(1:27, size = 1, prob = EnglishLetterFreq)]
}else{
CurrentString <- paste(CurrentString, NextLetter, sep = "", collapse = "")
}
start <- str_length(CurrentString) - Order + 1
if(start < 1){
start <- 1
}
end <- str_length(CurrentString)
CurrentString <- str_sub(CurrentString, start = start, end = end)
res <- paste(res, NextLetter, sep = "", collapse = "")
cat("\r", res)
if(str_length(res) >= n){break}
}
cat("\n")
return(res)
}
# Order = The order of the Markov Chain
# n = The length of the output string
GenerateWords(Order = 3, n = 20)
data(tworegime)
trait[,4] <- abs(rnorm(length(tree$tip.label), mean = 1, sd = 1/10))
alpha=c(5, 10)
require(OUwie)
data(tworegime)
trait[,4] <- abs(rnorm(length(tree$tip.label), mean = 1, sd = 1/10))
alpha=c(5, 10)
sigma.sq=c(1, 2)
theta=c(5, 10)
INV <- c(OUwie.fixed(tree,trait,model=c("OUMVA"), simmap.tree=FALSE, scaleHeight=FALSE, mserr = "known", clade=NULL, alpha=alpha,sigma.sq=sigma.sq,theta=theta, algorithm = "invert", quiet=TRUE)$loglik)
TPT <- OUwie.fixed(tree,trait,model=c("OUMVA"), simmap.tree=FALSE, scaleHeight=FALSE, mserr = "known", clade=NULL, alpha=alpha,sigma.sq=sigma.sq,theta=theta, algorithm = "three.point", quiet=TRUE)$loglik
comparison <- identical(round(INV, 5), round(TPT, 5))
comparison
skip_on_cran()
data(tworegime)
set.seed(42)
sigma.sq=c(0.2424788, 0.7007112)
theta <- c(1.4719377, 1.4719377)
BMSInvert <- OUwie.fixed(tree, trait, model=c("BMS"), simmap.tree=FALSE, scaleHeight=TRUE, clade=NULL, sigma.sq=sigma.sq, shift.point=0.5, algorithm="invert")
BMS3Point <- OUwie.fixed(tree, trait, model=c("BM1"), simmap.tree=FALSE, scaleHeight=TRUE, clade=NULL, sigma.sq=sigma.sq, theta=theta, shift.point=0.5, algorithm="three.point")
comparison <- identical(round(as.numeric(BMSInvert$loglik),5), round(as.numeric(BMS3Point$loglik),5))
expect_true(comparison)
comparison
#
require(corHMM)
require(OUwie)
require(parallel)
require(geiger)
require(proftools)
phy <- sim.bdtree(b = 1, d = 0.5, stop = "taxa", n = 250)
phy <- drop.extinct(phy)
root.p = c(0.5, 0.5)
p.mk <- c(0.1, 0.1)
alpha = c(1, 1)
sig2= c(0.1, 0.1)
theta = c(3, 8)
Q = matrix(c(-p.mk[1],p.mk[2],p.mk[1],-p.mk[2]), 2, 2)
theta0 = 5
rate.cat = 1
model.cor = "ER"
model.ou = "OUM"
data <- OUwie:::hOUwie.sim(phy, Q, root.p, alpha, sig2, theta0, theta)[[1]]
data
data <- OUwie:::hOUwie.sim(phy, Q, root.p, alpha, sig2, theta0, theta)[[1]]
p = c(0.1, 0.01, 0.1, 3, 8)
hOUwie.dat <- OUwie:::organizeHOUwieDat(data)
nObs <- length(hOUwie.dat$ObservedTraits)
model.set.final <- corHMM:::rate.cat.set.corHMM.JDB(phy=phy,data=hOUwie.dat$data.cor,rate.cat=rate.cat, ntraits = nObs, model = model.cor)
phy <- reorder(phy, "pruningwise")
index.ou <- OUwie:::getParamStructure(model.ou, "three.point", FALSE, FALSE, dim(model.set.final$Q)[2])
OUwie:::hOUwie.dev(p = log(p), phy = phy, data.cor = OUwie:::organizeHOUwieDat(data)$data.cor, data.ou = OUwie:::organizeHOUwieDat(data)$data.ou, liks = model.set.final$liks, Q=model.set.final$Q, rate=model.set.final$rate, root.p=root.p, rate.cat=rate.cat, index.ou=index.ou, model.ou=model.ou, nSim=100, nCores=1, algorithm = "three.point")
debug(OUwie:::hOUwie.dev)
OUwie:::hOUwie.dev(p = log(p), phy = phy, data.cor = OUwie:::organizeHOUwieDat(data)$data.cor, data.ou = OUwie:::organizeHOUwieDat(data)$data.ou, liks = model.set.final$liks, Q=model.set.final$Q, rate=model.set.final$rate, root.p=root.p, rate.cat=rate.cat, index.ou=index.ou, model.ou=model.ou, nSim=100, nCores=1, algorithm = "three.point")
OU.loglik
TPT <- unlist(OU.loglik)
OU.loglik <- mclapply(simmap, function(x) OUwie.fixed(x,
data.ou, model = model.ou, simmap.tree = TRUE, scaleHeight = FALSE,
clade = NULL, alpha = alpha, sigma.sq = sigma.sq, theta = theta,
check.identify = FALSE, algorithm = "invert", tip.paths = tip.paths,
quiet = TRUE)$loglik, mc.cores = nCores)
TPT
INV <- unlist(OU.loglik)
INV
INV == TPT
require(OUwie)
?OUwie
# this script will run corHMM analyses on the 4 datasets
# set wd
wd <- "~/2021_SeedDispersal/"
setwd(wd)
## imports
require(corHMM)
## functions
clean_dat <- function(csv, tre, remove=TRUE){
# read files
dat <- read.csv(csv)[,c(1,2)]
phy <- read.tree(tre)
missing_data <- c("remove","no_info","doubtful")
# if unknown data is to be removed, remove it
# else, replace with unknown (?)
if(remove == TRUE){
phy <- drop.tip(phy, dat[,1][which(dat[,2] %in% missing_data)])
dat <- dat[dat[,1] %in% phy$tip.label,]
dat <- dat[order(match(dat[,1],phy$tip.label)),]
}else{
dat[dat[,2] %in% missing_data,2] <- "?"
dat <- dat[order(match(dat[,1],phy$tip.label)),]
}
if(length(phy$tip.label) != length(dat[,1])){
return(cat("James messed up, the data and phylogeny don't match"))
}
return(list(dat = dat, phy = phy))
}
runCorHMM <- function(data_list, name, nStarts=0, nCores=1){
dat <- data_list$dat
phy <- data_list$phy
# ER
res_ER <- corHMM(phy = phy, data = dat, rate.cat = 1, model = "ER", node.states = "marginal", nstarts = nStarts, n.cores = nCores)
# ARD
res_ARD <- corHMM(phy = phy, data = dat, rate.cat = 1, model = "ARD", node.states = "marginal", nstarts = nStarts, n.cores = nCores)
# ER/ER
res_ER.ER <- corHMM(phy = phy, data = dat, rate.cat = 2, model = "ER", node.states = "marginal", get.tip.states = TRUE, nstarts = nStarts, n.cores = nCores)
# ARD/ARD
res_ARD.ARD <- corHMM(phy = phy, data = dat, rate.cat = 2, model = "ARD", node.states = "marginal", get.tip.states = TRUE, nstarts = nStarts, n.cores = nCores)
# ER/ARD
R1 <- getStateMat4Dat(dat, model = "ER")$rate.mat
R2 <- getStateMat4Dat(dat, model = "ARD")$rate.mat
mat_ER.ARD <- getFullMat(list(R1, R2))
res_ER.ARD <- corHMM(phy = phy, data = dat, rate.cat = 2, rate.mat = mat_ER.ARD, node.states = "marginal", get.tip.states = TRUE, nstarts = nStarts, n.cores = nCores)
obj <- list(res_ER = res_ER,
res_ARD = res_ARD,
res_ER.ER = res_ER.ER,
res_ARD.ARD = res_ARD.ARD,
res_ER.ARD = res_ER.ARD)
save(obj, file = paste0(name, "-", format(Sys.time(), "%y_%m_%d"), "-corRes.Rsave"))
return(obj)
}
dat <- data_list$dat
data_list <- data[,2]
data[,2]
## import and organize the data
labels <- unlist(lapply(strsplit(sort(dir("trait_data/")), "_"), function(x) x[1]))
csv <- paste0(wd, "trait_data/", sort(dir("trait_data/")))
tre <- paste0(wd, "trees/", sort(dir("trees/")))
data <- mapply(clean_dat, csv, tre, TRUE)
data[,2]
data_list <- data[,1]
dat <- data_list$dat
phy <- data_list$phy
# ER/ARD
ER <- getStateMat4Dat(dat, model = "ER")$rate.mat
ARD <- getStateMat4Dat(dat, model = "ARD")$rate.mat
ER
ARD
mat_ER.ARD.2 <- getFullMat(list(R1, R2), ARD)
mat_ER.ARD.2 <- getFullMat(list(ER, ARD), ARD)
mat_ER.ARD.2
mat_ER.ARD.2 <- getFullMat(list(ARD, ARD), ARD)
mat_ARD.ARD.1 <- getFullMat(list(ARD, ARD), ER)
mat_ARD.ARD.1
mat_ARD.ARD.2
mat_ARD.ARD.2 <- getFullMat(list(ARD, ARD), ARD)
mat_ARD.ARD.2
# ER/ER
mat_ER.ER.1 <- getFullMat(list(ER, ER), ER)
mat_ER.ER.1
dat <- data_list$dat
phy <- data_list$phy
ER <- getStateMat4Dat(dat, model = "ER")$rate.mat
ARD <- getStateMat4Dat(dat, model = "ARD")$rate.mat
# ER/ER
mat_ER.ER.1 <- getFullMat(list(ER, ER), ER)
res_ER.ER.1 <- corHMM(phy = phy, data = dat, rate.cat = 2, rate.mat = mat_ER.ER.1, node.states = "marginal", get.tip.states = TRUE, nstarts = nStarts, n.cores = nCores)
